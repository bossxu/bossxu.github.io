---
title: java设计模式
date: 2019-03-23 13:51:29

tags: ["面对对象","设计模式"]
mathjax: true


### 这是啥
> 设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。讲道理这个还是挺重要的。反正我看自己写的代码，感觉挺丑的。
> 四人帮提出的一个思想，是面对对象中常用的设计原则，关键的思想在于
+ 对接口编程而不是对实现编程。
+ 优先使用对象组合而不是继承。
> 主要学习是通过看[菜鸟教程](http://www.runoob.com/design-pattern/decorator-pattern.html)

### 分类
+ 创建型模式
这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
+ 结构型模式
这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
+ 行为型模型
这些设计模式特别关注对象之间的通信。
+ J2EE 模式
这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。

### 6大原则
+ 开闭原则
对扩展开放，对修改关闭。

+ 里氏代换原则（Liskov Substitution Principle）
任何基类可以出现的地方，子类一定可以出现

+ 依赖倒转原则
针对接口编程，依赖于抽象而不依赖于具体

+ 接口隔离原则
使用多个隔离的接口，比使用单个接口要好。目的在于降低类之间的耦合度

+ 迪米特法则，最少知道原则
一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立

+ 合成复用原则
尽量使用合成/聚合的方式，而不是使用继承

> emememem 可以说很复杂了

### 工厂模式
+ 创建型模式
+ 目的：**定义一个创建对象的接口**，让子类自己去决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
+ 个人看法，这个好像就是说，做一个接口去实现对象的创建，目的有啥呢，一个是扩展性好，加产品加一个工厂，加一个实现类就完事了[额，感觉到后面会越来越多]，还有就是封装性？还有就是，他说是对一些比较复杂的对象有好处。

### 抽象工厂模式
+ 是围绕一个超级工厂创建其他工厂
+ 目的：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
+ 个人看法，不是说对扩展开放，对修改关闭，问题这里，没有办法解决把，增加一个类，则要增加一个类，也要加一个工厂，但是这里的抽象工厂也是要进行修改才行。不过也只是要修改那个工厂制作的东西

### 单例模式
+ 只能有一个实例，并且只能自己去创建自己的实例，单例类必须给所有其他对象提供这一实例
+ 目的在于解决一个全局使用得类频繁的创建与销毁
+ 几种实现的方式，目的在于一个安全性的考虑

#### 懒汉式模式
+ lazy初始化
+ 多线程不安全
```java
public class xianchen
{
    private static xianchen instance;
    private xianchen(){}
    public static xianchen getinstance()
    {
        if(instance == null)
            instance = new xianchen();
        return instance;
    }
}
```
#### 懒汉式，线程安全
+ lazy初始化
+ 多线程安全(加了一个synchronized锁)
> 这个synchronized是java的一种同步锁，这里旧的说同步是啥，线程同步主要的目的是防止不同的线程对同一个文件同时进行操作造成奇奇怪怪的操作。然后这里又涉及到了进程与线程，还有java的多线程，哇，好菜啊，啥都不会。
```java
public class xianchen
{
    private static xianchen instance;
    private xianchen(){}
    public static synchronized xianchen getinstance()
    {
        if(instance == null)
            instance = new xianchen();
        return instance;
    }
}
```
#### 饿汉式，线程安全
+ 没lazy初始化
+ 它基于 classloader 机制避免了多线程的同步问题，
```java
public class xianchen
{
    private static xianchen instance = new xianchen();
    private xianchen(){}
    public static xianchen getInstance()
    {
        return instance;
    }
}
```
#### 双检锁/双重校验锁
+ lazy初始化
+ 多线程安全
+ volatile目的在于防止编译器优化，编译器在每次用到这个变量时会小心的**重新**读取这个变量的值，而不是使用保存在寄存器的备份。
```java
public class xianchen
{
    private volatile static xianchen instance;
    private xianchen(){}
    public static xianchen getXianchen()
    {
        if(instance == null )
        {
            synchronized(instance.class)
            {
                if(instance == null)
                {
                    instance = new xianchen();
                }
            }
        }
        return instance
    }
}
```
<<<<<<< HEAD
#### 静部内态类
+ lazy初始化
+ 多线程安全
+ 对静态域进行延迟初始化,这个的目的在于，只有getinstance被显式调用的时候，才会显式装载xianchen类
```java
public class xianchen
{
    private static class xianchenHolder
    {
        private static final xianchen instance = new xianchen();
    }
    private xianchen(){}
    public static final xianchen getinstance()
=======
#### 登记式/静态内部类
+ lazy初始化
+ 多线程安全(classloader)
+ 目的在于延迟加载实例，**只有显式调用才能出现显式装载**
```java
public class xianchen
{
    private static class xianchenHolder{
        private static final xianchen instance = new xianchen()
    }
    private xianchen(){}
    public static final xianchen getInstance 
>>>>>>> 6a09bfbd5e2c22b3e13f6d0737460d190dded675
    {
        return xianchenHolder.instance;
    }
}
```
<<<<<<< HEAD

#### 枚举
+ 好像不太实用


###  建造者模式

+ 将一个复杂的构建与表示相分离
+ 一些基本部件不会变，而其组合经常变化。
+ 将变与不变分离开

### 原型模式

+ 用于创建重复的对象，同时又能保证性能。
+ 常用于直接创建对象的代价比较大的时候

### 适配器模式

+ 作为两个互相不兼容的接口之间的桥梁
+ 将一个类的接口转换成客户希望的另外一个接口
+ 解决方法：继承和依赖

### 桥接模式

+ 将抽象和现实分离开，解决的是类继承爆炸的问题。
+ 得理解那个抽象得意义，感觉就是把它内部的一些常用的接口给提出来，然后对这个接口进行实例的操作。

### 过滤器模式

+ 对于不用的类，有不同的过滤方式，比如说list<num>,和list<float>都有不同的过滤方式。就是传进来的是一个集合，但是对于里面的数据，怎么过滤出需要的元素。

### 组合模式
+ 将对象组合成树形结构已表示“部分整体”的层次结构，组合模式让单个对象和组合对象的使用具有一致性。感觉就是vector里面加vector

### 装饰器模式
+ 允许向一个现有的类添加新的功能
+ 感觉是通过继承的方法来解决的。然后它又说子类太多很麻烦
+ 用一个抽象类，加一个修饰类，抽象类不具体实现，修饰类去实现。


### 外观模式
+ 目的是隐藏系统的复杂性，向客户端提供了一个可以访问系统的接口
+ 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
+ 相当于那个前台

### 享元模式
+ 目的：减少创建对象的数量
+ 加一个hashmap，看某个文件是不是出现过，没出现过就初始化，不然就从内存池里面拿出来。
+ java里面的string

### 代理模式
+ 一个类代表另一个类的功能
+ 增加中间层
+ windows中的中间层

### 责任链模式
+ 为请求创建了一个接收者对象的链
+ 目的在于将请求者和发送者解耦，好像感觉只有在多线程才会出事。
+ 有多个对象可以处理同一个请求，具体哪个对象处理，由那个时刻处理

### 命令模式
+ 将命令分装成一个对象进行处理
+ 感觉这个还是挺好理解的

### 解释器模式
+ 好像是说，相当于是一个解释器，像sql查询语句就是这样，对一些看起来可能不同的语言进行解析。

### 迭代器模式
+ 这个熟悉，c++中的set，map的遍历就是用这个

### 中介者模式
+ 用来降低多个对象和类之间的通信复杂度
+ 操作时将网状结构分离成星型结构(中心论)
+ 比如聊天室

### 备忘录模式
+ 在不破坏封装性的前提下，获得一个对象的内部状态，并在对象之外保存这个状态
+ 像存档

### 观察者模式
+ 存在一对多的关系时，当一个被改时，被依赖的类会被通知并自动更新。
+ 用一个集合去存这个

### 状态者模式
+ 就是类的行为是由它的状态决定的
+ 但是这个对象，不同的状态对象还是不同的。

### 空对象模式

+ 继承一下，一个抽象类，一个实例类，一个啥都不去做的空类，感觉没啥用，除了体系更健全。

### 策略模式
+ 一个类的行为和算法能在运行时更改
+ 将算法打包成类，进行替换操作。不过几个算法要差不多，分装好才行。

### 模板模式
+ 抽象类公开定义执行它的方法/模板。
+ 它的子类可以按需要重写方法实现
+ 好像没啥说的，就是很正常的。

### 访问者模式
+ 将数据与数据结构分离开
+ 在被访问的类里面加一个对外提供接待访问者的接口。
+ 感觉这个的目的就在于防止对数据本生进行操作(加一层，有用？可能自我欺骗，嘿嘿嘿)

### mvc模式
+ Model-View-Controller（模型-视图-控制器） 模式，这个好像是挺重要的一个模式，之前就听说过这个东西。用于分层开发。
+ model 代表一个存取数据的对象
+ view 视图代表包含数据的可视化
+ controller 控制器作用于模型和视图上，他控制数据流向模型对象，并在数据变化时更新视图
+ 不过咋感觉和那个适配器有点像，控制器那个

### 业务代表模式
+ 用于对表示层和业务层解耦，前端和后端分离？
+ 业务实现向外暴露统一接口。由业务代表来具体查询和掉用业务接口执行相关业务，而客户则只需要想业务代表调用相关简化后的接口即可实现响应业务。
+ 好像springboot里面的controler和service，集成一下，再暴露给外面。

### 组合实体模式
+ 说用在ejb持久化机制里面？？？？
+ 先码着，四个参与者
+ 组合实体，粗粒度对象，依赖对象，策略
+ ememe看那个例子，感觉就是

### 数据访问对象模式
+ 用在把低级的数据访问api从高级的业务服务中分离出来。
+ 三个组成部分
+ 数据访问对象接口
+ 数据访问对象实体类
+ 模型对象/数值对象
+ 这个感觉好像还挺重要的，对象于数据库里面一行进行对应。

### 前端控制器模式
+ 目的在于提供一个集中的请求处理机制
+ 前端控制器： 处理应用程序所有类型请求的单个处理程序
+ 调度器：前端控制器可能使用一个调度器对象来调度请求到相应的具体处理程序
+ 视图是为请求而创建的对象

### 拦截过滤器模式
+ 目的是对应用程序的请求或响应做一些预处理/后处理，

### 服务定位器模式
+ 目的是利用缓存来解决在查找服务代价高的问题

### 传输对象模式
+ 用于客户端向服务器一次性传递多个带属性的数值
+ 感觉就是相当于多一个模板从省城的作用


## 总结
> 哇,23个设计模式，好多啊，看的我头皮发麻，很多感觉也只是一知半解，这个还是得通过以后得面对对象编程去总结经验。这个并不是什么教学啊，这只是我的个人笔记，有想法的去看[菜鸟教程](http://www.runoob.com/design-pattern/decorator-pattern.html)
> 这个设计模式，主要的目的是提高一个代码的规范性，可扩展性，还有就是一些常见的面对对象的一个技巧，不管怎么说，万物皆对象。
=======
#### 枚举
+ 好象还没有普及使用



### 建造者模式
> 使用多个简单的对象一步一步构建成一个复杂的对象，这种类型的设计模式属于创建型模式，**提供了一种创建对象**
> 目的在于解决软件系统中，面临的“一个复杂对象”的创建工作，由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是组合他们的算法却相对稳定。
>>>>>>> 6a09bfbd5e2c22b3e13f6d0737460d190dded675
