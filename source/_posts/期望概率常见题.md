---
title: 期望，概率套题
tags: [ACM,期望,概率,dp]
comments: true
date: 2018-10-23 12:47:44
---

# 期望概率的一些水题   

## Aeroplane chess 
[ hdu4405 ](http://acm.hdu.edu.cn/showproblem.php?pid=4405)
### 描述
 >   Hzz loves aeroplane chess very much. The chess map contains N+1 grids labeled from 0 to N. Hzz starts at grid 0. For each step he throws a dice(a dice have six faces with equal probability to face up and the numbers on the faces are 1,2,3,4,5,6). When Hzz is at grid i and the dice number is x, he will moves to grid i+x. Hzz finishes the game when i+x is equal to or greater than N. 

 >   There are also M flight lines on the chess map. The i-th flight line can help Hzz fly from grid Xi to Yi (0<Xi<Yi<=N) without throwing the dice. If there is another flight line from Yi, Hzz can take the flight line continuously. It is granted that there is no two or more flight lines start from the same grid. 

 >   Please help Hzz calculate the expected dice throwing times to finish the game. 

### input
> There are multiple test cases. 
Each test case contains several lines. 
The first line contains two integers N(1≤N≤100000) and M(0≤M≤1000). 
Then M lines follow, each line contains two integers Xi,Yi(1≤Xi<Yi≤N).   
The input end with N=0, M=0. 

### output
> For each test case in the input, you should output a line indicating the expected dice throwing times. Output should be rounded to 4 digits after decimal point. 

### sample input
```
2 0
8 3
2 4
4 5
7 8
0 0
```

### sample output
```
1.1667
2.3441
```

### 题目意思
> 主要意思就是，有个人很爱玩飞行棋。他们在一张行为1列为n+1的棋盘上玩。然后他们有一个色子，色子有六个面，面上分别是1，2...，然后他们从0出发。其中这个棋盘上有m条飞机道，飞机道有两个口a,b(b>a);然后只要到了a那么它就会直接飞到b不用花费其他东西。现在就是问你从起点到终点需要丢多少次色子，求出这个期望。

### 思路
> - 首先看第一眼确定做法，期望dp.
> - 然后就是确定dp表达式的意思。$ dp[i] $ 这个表示从第i个点到终点的期望
> - 接着就是确定转移，以及初始状态。
>>  1. dp[n] = 0,
>>  2. dp[a] = dp[b] (如果有一条从a到b的飞机道).
>>  3. dp[i] = $\sum_{j=1}^6$ dp[i+j]/6  +1; 

###代码
```cpp
// langman
#include<bits/stdc++.h>
using namespace std;

#define clr(shu,x) memset(shu,x,sizeof(shu))
#define INF 0x3f3f3f3f
#define pi acos(-1)
#define loge exp(1)
#define ll long long
#define pb push_back
#define c_fuck(x) cout<<"Case "<<x<<":"
#define debug cout<<"is there bug?"<<endl
const int mod = 1e9+7;
const double eps = 1e-6;
// 期望入门题
// 网上说 概率dp一般是正着推 期望dp一般是倒过来退。
// 好像有点道理
// dp[i] 表式的是从i这个点 到第n个点所要用的期望。
double dp[100010];
int vis[100010];
int main()
{
  // std::ios::sync_with_stdio(false);
  // cin.tie(0);
  // cout.tie(0);
  int n,m;
  while(scanf("%d%d",&n,&m) == 2)
  {
    if(!m && !n) break;
    for(int i = 0;i<=n+6;i++)
    {
      dp[i] = 0;
      vis[i] = -1;
    }
    for(int i = 1;i<=m;i++)
    {
      int u,v;
      scanf("%d%d",&u,&v);
      vis[u] = v;
    }
    for(int i = n-1;i>=0;i--)
    {
      if(vis[i] != -1)
      {
        dp[i] = dp[vis[i]];
      }
      else
      {
        for(int j = 1;j<=6;j++)
        {
          dp[i] += dp[i+j]/6.0;
        }
        dp[i]+=1;
      }
    }
    printf("%.4lf\n",dp[0]);
  }
  return 0;
}
```
 